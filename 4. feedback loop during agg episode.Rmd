---
title: "exploratory analysis of auto-regression of biosensors"
output: html_document
date: "2023-11-10"
---


# Overview
To examine: if biosensor predicts end of aggressive behavior


````{r}

library(ggplot2)
library(dplyr)
library(lubridate)
library(psych)
library(reshape2)

library(survival)
set.seed(1234)
```
 


```{r}
path <- getwd()
setwd(path)
# all_data <- read.csv("all_data.csv", nrows = 200)
all_data <- read.csv("all_data.csv")

all_data$episode <- as.numeric(substring(all_data$file,9,10))

```


# select aggressive behavior = ON episodes



```{r}
all_data_agg_selected <- all_data[all_data$agg==1,]

```

```{r}

all_data_agg_selected$timestamp2 <-as.POSIXct(all_data_agg_selected$timestamp/1000, 
                             origin="1970-01-01",
                             tz = "UTC")
all_data_agg_selected$timestamp3 <-as.POSIXct(all_data_agg_selected$timestamp2,
                             format = "%Y-%m-%d %H:%M:%OS")


all_data_agg_selected <- all_data_agg_selected[order(all_data_agg_selected$id,
                                                     all_data_agg_selected$timestamp2),]
```

## compute gap between two records
```{r}
all_data_agg_selected <- all_data_agg_selected[order(
  all_data_agg_selected$id,
  all_data_agg_selected$session,
  all_data_agg_selected$episode,
  all_data_agg_selected$timestamp2
),]
all_data_agg_selected$time_gap <- difftime(all_data_agg_selected$timestamp2, 
                                           lag(all_data_agg_selected$timestamp2, 1), 
                                           units = "secs")
all_data_agg_selected$time_gap <- as.numeric(all_data_agg_selected$time_gap)

describe(all_data_agg_selected$time_gap)

all_data_agg_selected$new_agg_episode <- ifelse(all_data_agg_selected$time_gap==0.25,0,1)
 sum(all_data_agg_selected$new_agg_episode, na.rm = T)
 
 
agg_episode_by_id <- data.frame(all_data_agg_selected%>%
                                  group_by(id) %>% 
                                  summarize(
                                    total_episodes = sum(new_agg_episode, na.rm = T),
                                    count_seconds = n()/4
 ))

describe(agg_episode_by_id)

sum(agg_episode_by_id$total_episodes)
sum(agg_episode_by_id$count_seconds)
```


```{r}
all_data_agg_selected_scale <- data.frame(all_data %>%
                                            group_by(id, session, episode) %>%
                                            summarize(
                                              eda_m = mean(eda, na.rm = T),
                                              bvp_m = mean(bvp, na.rm = T),
                                              acc_x_m = mean(acc_x, na.rm = T),
                                              acc_y_m = mean(acc_y, na.rm = T),
                                              acc_z_m = mean(acc_z, na.rm = T)
                                            ))

all_data_agg_selected <- merge(all_data_agg_selected, all_data_agg_selected_scale, by = 
                                 c("id","session","episode"))

all_data_agg_selected$eda_demean <- all_data_agg_selected$eda - all_data_agg_selected$eda_m

all_data_agg_selected$bvp_demean <- all_data_agg_selected$bvp - all_data_agg_selected$bvp_m

all_data_agg_selected$acc_x_demean <- all_data_agg_selected$acc_x - all_data_agg_selected$eda_m

all_data_agg_selected$acc_y_demean <- all_data_agg_selected$acc_y - all_data_agg_selected$acc_y_m

all_data_agg_selected$acc_z_demean <- all_data_agg_selected$acc_z - all_data_agg_selected$acc_z_m

```

# usem

```{r}

# for each new episode of agg, run usem on acc, bvp, eda if it's long enough
# check if recovery time is related to total duration of this episode
all_data_agg_selected$agg_epsiode_index <- rep(1,
                                               nrow(all_data_agg_selected))
for (row in 2:nrow(all_data_agg_selected)){
  if(all_data_agg_selected$new_agg_episode[row]==1){
    all_data_agg_selected$agg_epsiode_index[row]<-
      all_data_agg_selected$agg_epsiode_index[row-1] +1
  }else{
    all_data_agg_selected$agg_epsiode_index[row]<-
      all_data_agg_selected$agg_epsiode_index[row-1] 
  }
}

```



```{r}
library(pompom)

rt_collect <- NULL

pdf("usem test.pdf")
for (episode_index in  unique(all_data_agg_selected$agg_epsiode_index))
{
  episode_data <- all_data_agg_selected[all_data_agg_selected$agg_epsiode_index==episode_index,]
  usem_data <- episode_data[c("eda","bvp","acc_x","acc_y","acc_z")]
  
  if (nrow(usem_data) < 5 * 15){
    next
  }else{
    
  plot_usem_data <-usem_data
  plot_usem_data$t <-1:nrow(plot_usem_data)
  
  usem_data_melt <- melt(plot_usem_data, 
                         id.vars = "t")
  
  
  
  print(ggplot(data = usem_data_melt,
               aes(x = t,y=value, group = variable,color = variable))+
          geom_line() +
          facet_wrap(~variable, scale ="free") + 
          theme_classic())
  
  
  
  usem_data <- scale(usem_data)
  
  m1 <- uSEM(5,usem_data, lag.order = 1,verbose = F,trim=T)
  
    ms_indiv <- model_summary(model.fit = m1,
                            var.number = 5,
                            lag.order = 1)

    if (length(ms_indiv)==1 ){
      next
    }
    # ms_indiv
    
    #plot model as network
    plot_network_graph(ms_indiv$beta, var.number =5)
    
    good_fit <- sum(ms_indiv$cfi > .95,
      ms_indiv$tli > .95,
      ms_indiv$rmsea < .08,
      ms_indiv$srmr < .08) >= 3

    #compute recovery time for all nodes
    recovery_time <- iRAM(model.fit = m1,
         beta = ms_indiv$beta,
         var.number = 5,
         lag.order = 1,
         threshold = 0.01,
         boot = TRUE,
         replication = 200, steps = 100)
    
    # rt_mean <- mean(rowMeans(recovery_time$mean, na.rm = T), na.rm = T)
    rt_vec <- diag(recovery_time$mean)
    rt_collect <-rbind(rt_collect,
                       c(episode_index,good_fit, rt_vec))
    
  }
  
}

dev.off()
```

```{r}
agg_by_id <- data.frame(all_data_agg_selected %>% 
                          group_by(agg_epsiode_index) %>%
                          summarize(duration_secs = n()/4))

rt_collect <- data.frame(rt_collect)
names(rt_collect) <-c("agg_epsiode_index","good_fit",paste("rt",1:5, sep ="_"))

rt_collect <- merge(agg_by_id,rt_collect, by = "agg_epsiode_index")

rt_collect$rt_mean <- rowMeans(rt_collect[c(paste("rt",1:5,sep="_"))], na.rm = T)

ggplot(data = rt_collect, aes(x = rt_mean , y = duration_secs))+
  geom_point()+
  geom_jitter()
```
