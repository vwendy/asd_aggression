---
title: "explore"
output: html_document
date: "2023-11-10"
---


````{r}

library(ggplot2)
library(dplyr)
library(lmerTest)
library(lme4)
library(lubridate)
library(psych)
```
```{r}
path <- getwd()
setwd(path)
# all_data <- read.csv("all_data.csv", nrows = 200)
all_data <- read.csv("all_data.csv")

all_data$episode <- as.numeric(substring(all_data$file,9,10))

```

# compute AR
```{r}

id_list <- unique(all_data$id)
time_window <- 180 # seconds
predict_window <- 60 # seconds
sampling_rate <- 4
sliding_unit <- predict_window * sampling_rate # data points, 60 seconds

window_data_collect <- NULL

# pdf("scatter plot AR of EDA vs. Agg.pdf")
for (id in id_list){
  id_data <- all_data[all_data$id == id,]
  session_list <- unique(id_data$session)
  for (session in session_list){
    id_session_data <- id_data[id_data$session == session,]
    episode_list <- unique(id_session_data$episode)
  
    for (episode in episode_list){
      id_episode_data <- id_session_data[id_session_data$episode == episode,]
      id_episode_data$timestamp2 <-as.POSIXct(id_episode_data$timestamp/1000, 
                                   origin="1970-01-01",
                                   tz = "UTC")
      id_episode_data$timestamp3 <-as.POSIXct(id_episode_data$timestamp2,
                                   format = "%Y-%m-%d %H:%M:%OS")
        
      id_episode_data <- id_episode_data[order(id_episode_data$timestamp3),]
      # id_episode_data$eda_diff <- id_episode_data$eda - lag(id_episode_data$eda,1)
      
      
      id_episode_data$ar <- rep(NA, nrow(id_episode_data))
      id_episode_data$avg_eda <- rep(NA, nrow(id_episode_data))
      id_episode_data$sd_acc_x <- rep(NA, nrow(id_episode_data))
      id_episode_data$sd_acc_y <- rep(NA, nrow(id_episode_data))
      id_episode_data$sd_acc_z <- rep(NA, nrow(id_episode_data))
      id_episode_data$predict_agg <- rep(NA, nrow(id_episode_data))
      id_episode_data$predict_sib <- rep(NA, nrow(id_episode_data))
      id_episode_data$predict_ed <- rep(NA, nrow(id_episode_data))
      
      id_episode_data$mdistance <- rep(NA, nrow(id_episode_data))
      id_episode_data$ar_mdistance <- rep(NA, nrow(id_episode_data))
      id_episode_data$avg_mdistance <- rep(NA, nrow(id_episode_data))
      
      id_episode_data$cr_etod <- rep(NA, nrow(id_episode_data))
      id_episode_data$cr_dtoe <- rep(NA, nrow(id_episode_data))
    
      if (time_window*sampling_rate+1  < 
          nrow(id_episode_data) -
          predict_window*sampling_rate  - 
          sliding_unit){
        for (row in seq(time_window*sampling_rate+1 ,
                        nrow(id_episode_data) - 
                        predict_window*sampling_rate , 
                        sliding_unit)
             ){
          AR_model <- lm(eda~lag(eda,1), 
                         data = id_episode_data[(row -time_window*sampling_rate) :row, ])  
          ar_param <- coefficients(summary(AR_model))[2,1]
          id_episode_data$ar[row] <- ar_param
          id_episode_data$avg_eda[row] <- mean(id_episode_data[(row
                                                                -time_window*sampling_rate)
                                                               :row, ]$eda, 
                                               na.rm = T)
          
          # Mahalanobis  distances
          selected_rows_df <- id_episode_data[(row -time_window*sampling_rate) :row, ] 
          S <- var(selected_rows_df[c("acc_x","acc_y","acc_z")])
          M <- colMeans(selected_rows_df[c("acc_x","acc_y","acc_z")])
          
          
          if (sum(S)==0){
            # do nothing
            print("do nothing")
          
          }else{
            id_episode_data[(row -time_window*sampling_rate) :row,]$mdistance <-
              mahalanobis(x =selected_rows_df[c("acc_x","acc_y","acc_z")] , 
                                   center = M , 
                                   cov = S)
          
            mdistance_AR_model <- lm(mdistance~lag(mdistance,1), 
                                          data = id_episode_data[(row
                                                                  -time_window*sampling_rate)
                                                                 :row, ])  
            mdistance_ar_param <- coefficients(summary(mdistance_AR_model))[2,1]
            id_episode_data$ar_mdistance[row] <- mdistance_ar_param
            id_episode_data$avg_mdistance[row] <- 
              mean(id_episode_data[(row -time_window*sampling_rate) :row, ]$mdistance, 
                   na.rm = T)
            
            
            CR_model1 <- lm(mdistance~lag(eda,1), 
                                          data = id_episode_data[(row
                                                                  -time_window*sampling_rate)
                                                                 :row, ])  
            
            cr_etod_param <- coefficients(summary(CR_model1))[2,1]
            id_episode_data$cr_etod[row] <- cr_etod_param
            
            CR_model2 <- lm(eda~lag(mdistance,1), 
                                          data = id_episode_data[(row
                                                                  -time_window*sampling_rate)
                                                                 :row, ])  
            
            cr_dtoe_param <- coefficients(summary(CR_model2))[2,1]
            id_episode_data$cr_dtoe[row] <- cr_dtoe_param
            
          }
       
          
          
          
          id_episode_data$sd_acc_x[row] <- sd(id_episode_data[(row -time_window*sampling_rate) :row, ]$acc_x, na.rm = T)
          
          
          
          id_episode_data$sd_acc_y[row] <- sd(id_episode_data[(row -time_window*sampling_rate) :row, ]$acc_y, na.rm = T)
          
          
          
          id_episode_data$sd_acc_z[row] <- sd(id_episode_data[(row -time_window*sampling_rate) :row, ]$acc_z, na.rm = T)
          
          
          
          
          id_episode_data$predict_agg[row] <- mean(id_episode_data$agg
                                                   [row: (row +predict_window*sampling_rate)], 
                                                   na.rm = T)
          
          id_episode_data$predict_sib[row] <- mean(id_episode_data$sib
                                                   [row: (row +predict_window*sampling_rate)], 
                                                   na.rm = T)
          id_episode_data$predict_ed[row] <- mean(id_episode_data$ed
                                                   [row: (row +predict_window*sampling_rate)], 
                                                   na.rm = T)
        }
        
        
        # print(ggplot(data = id_episode_data, aes(x = ar_mdistance, y = predict_agg, color = avg_eda))+
        #     geom_point()+
        #     xlim(0,1)+
        #     ggtitle(paste(id, session,episode, sep =",")) +
        #     theme_classic())
        # 
        window_data_collect <- rbind(window_data_collect, 
                                     id_episode_data
                                     # [!is.na(
                                     #   id_episode_data$ar),]
                                     )
        
      }else{
        next
      }
      
      
    }
    }
}

# dev.off()
```



```{r}
write.csv(window_data_collect,paste( "processed_ar", sliding_unit, ".csv", sep =""))

```


```{r}
# relation between ar eda and agg
print(ggplot(data = window_data_collect, aes(x = cr_etod, y = predict_agg, group  = id, 
                                      color = factor(id)))+
    geom_point()+
    xlim(-1,1)+
    theme_classic())

```

```{r}
# relation between avg eda and agg
print(ggplot(data = window_data_collect[window_data_collect$id %in% id_list[41:50],], aes(x = avg_eda, y = predict_agg, group  = id, 
                                      color = factor(id)))+
    geom_point()+
    geom_smooth(se = F)+
      facet_wrap(~id, scale = "free") + 
    theme_classic())
```


between acc, x, y,z and eda
```{r}
print(ggplot(data = window_data_collect[window_data_collect$id %in% id_list[21:30],])+
        geom_point(aes(x =avg_eda  , y = sd_acc_x), color = "red")+
        geom_point(aes(x = avg_eda, y = sd_acc_y), color = "green")+
        geom_point(aes(x = avg_eda, y = sd_acc_z), color = "blue")+
        # geom_smooth(se = F)+
        facet_wrap(~id, scale = "free") + 
        theme_classic())
```

```{r}
# print(ggplot(data = window_data_collect[window_data_collect$id %in% id_list[2],])+
#         geom_point(aes(x =ar_mdistance  , y = agg), color = "red")+
#         # geom_smooth(se = F)+
#         facet_wrap(~id, scale = "free") +
#         theme_classic())
```

```{r}
# test <- data.frame(
#   window_data_collect %>%  group_by(id, session, episode) %>% 
#     summarize(
#       cor_eda_mdistance = coefficients(summary(lm(eda~ mdistance)))[2,1],
#       mean_eda = mean(eda, na.rm = T),
#       agg  = mean(agg, na.rm = T)
#       
#       )
#   )
# 
# ggplot(data = test, aes(x = cor_eda_mdistance, y = agg, color = mean_eda))+
#   geom_point()
```

# some evidence to show that positive feedback loops is related to aggressive behavior
light blue indicate higher aggressive proportion in the upcoming minute, the the diagnol line is when cross regression from eda to mdistance are both positive/negative, therefore a positive feedback loop, eg.., 1223, 4253
```{r}
# relation between cross regressions
window_data_collect$predict_agg_bin <- ifelse(window_data_collect$predict_agg >0,1,0)

for (index in seq(1,64,11)){
print(ggplot(data = window_data_collect[window_data_collect$id %in% id_list[index:min(length(id_list),(index+12))],], 
             aes(
               # x = ar, y = ar_mdistance,
               x = cr_etod, y = cr_dtoe,
                 color = factor(predict_agg_bin),alpha =.1))+
    geom_point()+
      geom_jitter()+
    xlim(-1,1)+
      ylim(-1,1)+
      facet_wrap(~id) + 
    theme_classic())
}

```

# treat aggression as continuous, mlm
```{r}
library(lme4)
library(lmerTest)

glm1 <- lmer(predict_agg~ 
               ar * avg_eda +
               ar_mdistance +
               cr_etod * 
               cr_dtoe + 
               # avg_mdistance + 
               (1  |id), 
             data = window_data_collect[!is.na(window_data_collect$ar),])

summary(glm1)

# empty model
# level 2 Variance:  6.761e-05
# level 1 Variance:  3.365e-03

# with predictors
# level 2 Variance:  8.439e-05
# level 1 Variance:  3.327e-03
```


# binary aggression

```{r}
# offset agg occurrent to 1 (modeling from 1 to 2 or more probability)
window_data_collect$predict_agg_bin <- ifelse(window_data_collect$predict_agg * 
                                         (predict_window*sampling_rate+1)>0
                                         ,1,0)

glm2 <- glmer(predict_agg_bin~ 
               ar * avg_eda +
               ar_mdistance +
               cr_etod * 
               cr_dtoe + 
               (1 |id), 
             family = "binomial",
             data = window_data_collect[!is.na(window_data_collect$ar),])

summary(glm2)

# cor(window_data_collect[!is.na(window_data_collect$ar),c("ar_mdistance","ar")], use = "complete.obs")
# 0.007471149
# hist(window_data_collect$ar_mdistance)

# empty model
# 
# Random effects:
#  Groups Name        Variance Std.Dev.
#  id     (Intercept) 2.591    1.61    
# Number of obs: 10464, groups:  id, 63
```

```{r}
ggplot(data = window_data_collect[window_data_collect$id==id_list[2]&
                           window_data_collect$episode==1,]
       )+
  geom_line(aes(x = timestamp3, y = mdistance/5), color ="blue") + 
  geom_line(aes(x = timestamp3, y = eda), color ="red") + 
  geom_line(aes(x = timestamp3, y = agg*20), color ="pink") + 
  theme_classic()
  
  
```

```{r}
library(pscl) #hurdle model

# Need to install from R-Forge instead of CRAN
# install.packages("countreg", repos="http://R-Forge.R-project.org")
library(countreg)

for (id in id_list){
  print(id)
    id_data  <- window_data_collect[window_data_collect$id==id,]
    id_data <- id_data[!is.na(id_data$ar),]
    id_data$predict_agg_count <- id_data$predict_agg * (predict_window*sampling_rate+1)
    id_data$predict_agg_count_bin <-ifelse(id_data$predict_agg_count >0,1,0)
    
    if (sum(id_data$predict_agg,na.rm = T)==0){
      next
    }else{
      # lm1 <- glmer(predict_agg_count~ 
      #                ar * avg_eda +
      #          ar_mdistance +
      #          cr_etod * 
      #          cr_dtoe + 
      #               (1 |episode)
      #               , 
      #            family = "poisson",
      #            data =id_data)
      # 
      # print(summary(lm1))
      # 
      hurdle1 <- hurdle(predict_agg_count~
                          ar +
                          ar_mdistance +
                          cr_etod*cr_dtoe|
                          avg_eda + avg_mdistance ,
                     dist = "poisson",
                     zero.dist = "binomial",
                     data =id_data)

      print(summary(hurdle1))
      sum(predict(hurdle1, type = "prob")[,1])
      
      
      # rootogram(hurdle1, max = predict_window*sampling_rate) 
    }
    


}
```

```{r}
ggplot(data = data_collect[!is.na(data_collect$ar),], aes(x = ar))+
  geom_histogram()


ggplot(data = data_collect[!is.na(data_collect$ar),], aes(x = avg_eda      ))+
  geom_histogram()


ggplot(data = data_collect[!is.na(data_collect$ar),], aes(x = predict_agg))+
  geom_histogram()
```

# guiding principle
dysregulation in physio system is a predictor of aggressive behavior (or sib, ed)
dysregulation is measured by dynamics in EDA, hand movements, bvp

metrics to test 
1. EDA AR(1)
2. mdistance of hand movement AR(1)
3. bivariate dynamics between EDA and hand movement
eda goes up to motivate hand movement (same direction)
hand movement might regulate frustraction (different direction)
if they form a positive feedback loop, then dysregulation is strong, might produce aggressive behavior

# prelim analysis
seems like AR>0 is essential for aggression, but not sufficient
agg => ar>0, but ar>0!=>agg

why when AR>0, there are sometimes Agg == 0? hurdle model? what is the reason? 
1. the level of EDA is zero, there are still a lot of inertia (control for level)
2. movement in ACC (computed mahalonobis distance between x, y, z)

## hurdle model shows for N = 10, AR doesn't affect agg from 0 to 1, but from 1 to more

# reference 
hurdle model
https://search.r-project.org/CRAN/refmans/pscl/html/hurdle.html

# question
what does the zero part mean?
if beta is >0, does it mean it's more likely for y to be 0 or 1?

# accelerometr
https://www.google.com/search?sca_esv=589973973&rlz=1C1ONGR_enUS1027US1027&sxsrf=AM9HkKkRsOOsMIKoQZlYlspnVnxPyMNxhQ:1702343399510&q=accelerometer+xyz&tbm=isch&source=lnms&sa=X&ved=2ahUKEwj32POs24iDAxUqFVkFHc2EBkEQ0pQJegQICxAB&biw=1360&bih=643&dpr=1
